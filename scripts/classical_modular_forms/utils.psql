CREATE OR REPLACE FUNCTION to_base26(IN n integer) RETURNS varchar AS $$
DECLARE
    s varchar;
    m integer;
BEGIN:
    m := n;
    IF m < 0 THEN
        s := 'NULL';
    ELSIF m = 0 THEN
        s := 'a';
    ELSE
        s := '';
        WHILE m != 0 LOOP
            s := chr(m%26+97) || s;
            m := m/26;
        END LOOP;
    END IF;

    RETURN s;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION from_base26(IN s varchar) RETURNS integer AS $$
DECLARE
    k integer[];
    m integer := 0;
    p integer := 1;
BEGIN
    k := array(SELECT ascii(unnest(regexp_split_to_array(reverse(s),''))) - 97);
    FOR l in 1 .. array_length(k,1) LOOP
        m := m + p*k[l];
        p := p*26;
    END LOOP;
    return m;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION from_newform_label_to_hecke_orbit_code(IN s varchar) RETURNS bigint AS $$
DECLARE
    v text[];
BEGIN
    v := string_to_array(s, '.');
    return v[1]::bigint + (v[2]::bigint::bit(64)<<24)::bigint + (from_base26(v[3])::bit(64)<<36)::bigint + (from_base26(v[4])::bit(64)<<52)::bigint;
END;
$$ LANGUAGE plpgsql;

//we could have only one function, but then we would play heavily for the if statement
CREATE OR REPLACE FUNCTION from_newspace_label_to_hecke_orbit_code(IN s varchar) RETURNS bigint AS $$
DECLARE
    v text[];
BEGIN
    v := string_to_array(s, '.');
    return v[1]::bigint + (v[2]::bigint::bit(64)<<24)::bigint + (from_base26(v[3])::bit(64)<<36)::bigint;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION prod_factorization(IN fact anyarray) RETURNS anyelement AS $$
DECLARE
    prod anyelement := 1;
BEGIN
    IF array_length(fact, 1) != 0 THEN
        FOR l in 1 .. array_length(fact, 1) LOOP
            prod := prod * (fact[l][1]^fact[l][2]);
        END LOOP;
    END IF;
    return prod;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION prod(IN list anyarray) RETURNS anyelement AS $$
DECLARE
    prod anyelement := 1;
BEGIN
    IF array_length(list, 1) != 0 THEN
        FOR i in 1 .. array_length(list, 1) LOOP
            prod := prod * list[i];
        END LOOP;
    END IF;
    return prod;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION prod2(IN list anyarray) RETURNS anyelement AS $$
DECLARE
    prod anyelement := 1;
BEGIN
    IF array_length(list, 1) != 0 THEN
        FOR i in 1 .. array_length(list, 1) LOOP
            prod := prod * list[i][2];
        END LOOP;
    END IF;
    return prod;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION check_cc_prod(IN am double precision[], IN an double precision[], IN amn double precision[]) RETURNS bool AS $$
BEGIN
    return @((am[1][1]*an[1][1] - am[1][2]*an[1][2]) - amn[1][1]) < 1e-13 AND @((am[1][1]*an[1][2] + am[1][2]*an[1][1]) - amn[1][2]) < 1e-13;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION traces(IN ans double precision[]) returns double precision[] AS $$
DECLARE
  res double precision[];
  x double precision[];
BEGIN
  res := array_fill(0, ARRAY[array_length(ans, 2)]);
  FOREACH x SLICE 2 IN ARRAY ans LOOP
    FOR i in 1 .. array_length(x, 1) LOOP
      res[i] := res[i] + x[i][1];
    END LOOP;
  END LOOP;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION scan_rows(double precision[]) RETURNS void AS $$
DECLARE
  x double precision[];
BEGIN
  FOREACH x SLICE 2 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
